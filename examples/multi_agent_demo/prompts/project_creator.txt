You are the Project Creator Agent for the Marcus Multi-Agent Demo.

Your ONLY task is to:

1. Use the mcp__marcus__create_project tool to create a new project called "Task Management API Demo"
2. Use this exact description:

# Task Management API - Project Specification

## Overview
Build a production-quality REST API for task management with authentication, user management, projects, tasks, and comments. The API must strictly follow the OpenAPI specification in `task_management_api_spec.yaml`.

## Technical Stack
- **Framework**: FastAPI (Python)
- **Database**: PostgreSQL with SQLAlchemy ORM
- **Authentication**: JWT tokens with bcrypt password hashing
- **Validation**: Pydantic v2 models
- **Testing**: pytest with 80%+ coverage requirement
- **Type Safety**: Full mypy compliance

## Feature Requirements

### 1. Database & Models
Create SQLAlchemy models for:
- **User**: id (UUID), email (unique), username (unique), password_hash, full_name, created_at, updated_at
- **Project**: id (UUID), name, description, owner_id (FK to User), status (enum: active/archived/completed), created_at, updated_at
- **Task**: id (UUID), title, description, project_id (FK), assigned_to (FK to User, nullable), status (enum: todo/in_progress/review/done), priority (enum: low/medium/high/urgent), due_date (nullable), created_at, updated_at
- **Comment**: id (UUID), task_id (FK), user_id (FK), content, created_at, updated_at

All relationships must be properly configured with foreign keys and cascade rules.

### 2. Authentication System
Implement JWT-based authentication:
- **POST /api/v1/auth/register**: Create new user, hash password with bcrypt, return user + JWT token
- **POST /api/v1/auth/login**: Validate credentials, return user + JWT token
- **Security**: All endpoints except auth require valid Bearer token
- **Token format**: JWT with user_id claim, 24-hour expiration

### 3. User Management
Implement user profile endpoints:
- **GET /api/v1/users/me**: Return current authenticated user's profile
- **PUT /api/v1/users/me**: Update current user's profile (username, email, full_name)
- **Validation**: Ensure email/username uniqueness on updates

### 4. Project Management
Implement full CRUD for projects:
- **GET /api/v1/projects**: List projects for authenticated user with pagination (page, limit) and status filtering
- **POST /api/v1/projects**: Create new project owned by authenticated user
- **GET /api/v1/projects/{project_id}**: Get project details (verify ownership/access)
- **PUT /api/v1/projects/{project_id}**: Update project (only owner can update)
- **DELETE /api/v1/projects/{project_id}**: Delete project and cascade to tasks (only owner)

Response format must match spec: `{items: [...], total: int, page: int, limit: int}` for lists.

### 5. Task Management
Implement task CRUD and assignment:
- **GET /api/v1/tasks**: List tasks with filters (project_id, status, priority, assigned_to) and pagination
- **POST /api/v1/tasks**: Create task in a project (verify user has access to project)
- **GET /api/v1/tasks/{task_id}**: Get task details
- **PUT /api/v1/tasks/{task_id}**: Update task (title, description, status, priority, due_date)
- **DELETE /api/v1/tasks/{task_id}**: Delete task
- **PUT /api/v1/tasks/{task_id}/assign**: Assign task to a user (verify user_id exists)

### 6. Comments
Implement task commenting:
- **GET /api/v1/tasks/{task_id}/comments**: List comments for task with pagination
- **POST /api/v1/tasks/{task_id}/comments**: Add comment to task (verify task exists and user has access)

### 7. Testing Requirements
Each feature area must have comprehensive tests:
- **Unit tests**: Test business logic, validation, error handling
- **Integration tests**: Test API endpoints end-to-end
- **Coverage**: Minimum 80% code coverage
- **Test scenarios**:
  - Happy path (valid requests)
  - Authentication failures (missing/invalid token)
  - Authorization failures (accessing other users' resources)
  - Validation errors (invalid input)
  - Not found errors (invalid IDs)
  - Constraint violations (unique email/username)

### 8. Error Handling
Consistent error responses matching OpenAPI spec:
```json
{
  "error": "error_code",
  "message": "Human readable message",
  "details": {}  // optional
}
```

Status codes:
- 200: Success
- 201: Created
- 204: No content (delete)
- 400: Bad request (validation)
- 401: Unauthorized (auth required)
- 403: Forbidden (no permission)
- 404: Not found
- 409: Conflict (unique constraint)
- 500: Server error

### 9. Data Validation
Use Pydantic schemas for request/response validation:
- All request bodies validated
- All responses typed
- Proper error messages for validation failures
- UUID format validation
- Email format validation
- Date format validation (ISO 8601)

### 10. Database Setup
- Alembic migrations for schema management
- Database initialization script
- Proper indexes on foreign keys and frequently queried fields
- Connection pooling configuration

## Non-Functional Requirements

### Performance
- Response time <100ms for CRUD operations
- Efficient database queries (use joins, avoid N+1)
- Connection pooling

### Security
- Passwords hashed with bcrypt (cost factor 12)
- JWT tokens properly signed and validated
- No SQL injection vulnerabilities (use parameterized queries)
- Input sanitization
- Rate limiting on auth endpoints (optional but recommended)

### Code Quality
- Type hints on all functions
- Numpy-style docstrings
- Zero mypy errors with strict mode
- Clear variable names
- Proper separation of concerns (routers, models, schemas, services)

### Documentation
- API documented via OpenAPI spec
- Code comments for complex logic
- README with setup instructions
- Environment variable documentation

## Task Breakdown Suggestions

This project can be effectively parallelized across multiple agents:

1. **Database & Core Setup** (Foundation)
   - SQLAlchemy models
   - Alembic migrations
   - Database connection setup
   - Base Pydantic schemas

2. **Authentication** (Can start after core setup)
   - JWT utilities
   - Password hashing
   - Auth endpoints (/register, /login)
   - Auth middleware/dependencies
   - Auth tests

3. **User Management** (Depends on auth)
   - User endpoints
   - User tests

4. **Project Management** (Can work in parallel with tasks after core setup)
   - Project endpoints
   - Project authorization logic
   - Project tests

5. **Task Management** (Can work in parallel with projects after core setup)
   - Task endpoints
   - Task assignment logic
   - Task tests

6. **Comments** (Depends on tasks)
   - Comment endpoints
   - Comment tests

7. **Integration & Validation** (Final phase)
   - Integration tests across features
   - API spec compliance validation
   - Performance testing
   - Documentation finalization

## Success Criteria

The project is complete when:
- ✅ All 15 endpoints implemented per OpenAPI spec
- ✅ All endpoints return correct response formats
- ✅ 80%+ test coverage achieved
- ✅ Zero mypy errors
- ✅ All tests passing
- ✅ API validation suite passes 100%
- ✅ Database migrations work correctly
- ✅ Authentication/authorization working
- ✅ Proper error handling throughout

## Notes for Agents

- Refer to `task_management_api_spec.yaml` as the source of truth for endpoint contracts
- Follow the error response format consistently
- Use dependency injection for database sessions and auth
- Write tests as you implement (TDD approach)
- Commit frequently with descriptive messages including task IDs
- Report progress at milestones (25%, 50%, 75%, completion)
- If blocked, use Marcus's blocker reporting for AI suggestions


3. Use these options: {"complexity": "standard", "provider": "planka", "mode": "new_project"}

4. When the project is created successfully:
   - Save the project_id and board_id to /Users/lwgray/dev/marcus/examples/multi_agent_demo/project_info.json
   - Print "PROJECT CREATED: project_id=<id> board_id=<board_id>"
   - Exit immediately

5. If creation fails, print the error and exit with code 1

DO NOT do anything else. Just create the project and exit.
